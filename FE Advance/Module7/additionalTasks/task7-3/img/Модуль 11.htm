<!DOCTYPE html>
<!-- saved from url=(0051)http://fecore.net.ua/advanced/theory/module-11.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,maximum-scale=1,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 11</title><link rel="stylesheet" href="./Модуль 11_files/styles.min.css"><script async="" src="./Модуль 11_files/ei.js"></script></head><body><div class="wrapper"><article><header><h1>Модуль 11 - Теория</h1><!-- ============================== page-navigator =============================================  --><ul id="page-nav"><li><a href="http://fecore.net.ua/advanced/theory/module-11.html#protocols">Введение в интернет протоколы</a></li><li><a href="http://fecore.net.ua/advanced/theory/module-11.html#rest">Ознакомление с REST архитектурой</a></li><li><a href="http://fecore.net.ua/advanced/theory/module-11.html#data">Форматы данных JSON/XML/CSV</a></li><li><a href="http://fecore.net.ua/advanced/theory/module-11.html#fetch">Fetch API</a></li><li><a href="http://fecore.net.ua/advanced/theory/module-11.html#api-basics">Основы работы с API</a></li></ul><!-- ============================== end page-navigator =============================================  --></header><!-- SECTION --><section><h2 id="protocols">Введение в интернет протоколы</h2><p><strong>Протокол</strong> — это набор правил и соглашений, используемых при передаче данных. Каждая программа, претендующая на работу в сети, должна следовать определенным правилам для приема и передачи данных.</p><p><strong>TCP/IP</strong> - основополагающий протокол сети Internet. Это два различных протокола, тесно связанных между собой.</p><p><strong>TCP (Transmission Control Protocol)</strong> - протокол управления передачей. Он определяет, каким образом информация должна быть разбита на пакеты и отправлена по каналам связи. TCP располагает пакеты в нужном порядке, а также проверяет каждый пакет на наличие ошибок при передаче.</p><p><strong>IP (Internet Protocol)</strong> – каждый информационный пакет содержит IP-адреса компьютера-отправителя и компьютера-получателя. Специальные компьютеры, называемые маршрутизаторами, используя IP-адреса, направляют информационные пакеты в нужную сторону, то есть к указанному в них получателю.</p><!-- subsection --><h3>HyperText Transfer Protocol (HTTP)</h3><p><strong>HTTP</strong> — протокол передачи данных прикладного уровня, изначально в виде гипертекстовых документов в формате HTML, в настоящий момент используется для передачи произвольных данных. Дефолтный TCP-порт - 80.</p><p>HTTP основан на модели архитектуры клиент-сервер и протоколе запроса/ответа без учета состояния, который работает путем обмена сообщениями через надежное TCP/IP соединение. Есть потребитель (клиент), который инициирует соединение и посылает запрос. И поставщик (сервер), который ожидает соединения для получения запроса, производит необходимые действия и возвращает обратно сообщение с результатом.</p><p>Основной объект манипуляции в HTTP - ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть и логические объекты. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения, клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.</p><p>HTTP определяет набор методов запроса для указания желаемого действия для данного ресурса.</p><ul><li><code>GET</code> - запрашивает данные от сервера</li><li><code>POST</code> - записывает данные на сервер</li><li><code>PUT</code> - обновляет данные на сервере путем замены</li><li><code>DELETE</code> - удаляет данные на сервере</li></ul><ul><li><a href="http://infocisco.ru/network_model_osi.html" target="_blank">Сетевая модель</a></li><li><a href="https://ru.wikipedia.org/wiki/URI" target="_blank">URI</a></li><li><a href="https://www.tutorialspoint.com/http/index.htm" target="_blank">Руководство по HTTP</a></li></ul><!-- subsection --><h4>Структура HTTP</h4><p>Каждое HTTP-сообщение состоит из трёх частей:</p><ul><li><code>Стартовая строка (start line|request-line|status-line)</code> - определяет тип сообщения.</li><li><code>Поля заголовков (message headers)</code> - это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение, которые предоставляют необходимую информацию о запросе или ответе или об объекте, отправленном в теле сообщения. Существует четыре типа заголовков HTTP-сообщений.</li><li><code>Тело сообщения (message body)</code> - непосредственно данные сообщения.</li></ul><!-- subsection --><h3>HyperText Transfer Protocol Secure (HTTPS)</h3><p><strong>HTTPS</strong> — расширение протокола HTTP, для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS. Дефолтный TCP-порт - 443.</p><p>HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы SSL и TLS. Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения, при условии что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют.</p><!-- subsection --><h4>SSL Сертификаты</h4><p>Чтобы подготовить веб-сервер для обработки https-соединений, администратор должен получить и установить в систему сертификат открытого ключа для этого веб-сервера. Сертификат открытого ключа подтверждает принадлежность данного открытого ключа владельцу сайта</p><p>Когда запрашивается HTTPS соединение к странице, сертификат открытого ключа и сам открытый ключ посылаются клиенту. Далее проиходит <code>SSL handshake (рукопожатие)</code> которое включает в себя генерацию 'секретов' для установления уникального безопасного соединения между клиентом и сервером. Закрытый ключ используется для расшифровки сообщений от клиента.</p><!-- subsection --><h4>Плюсы HTTPS</h4><ul><li>Информация о клиенте, например номера кредитных карт, зашифрована и не может быть перехвачена</li><li>Посетители могут подтвердить, что вы зарегистрированный бизнес и что у вас есть домен</li><li>Клиенты с большей вероятностью будут доверять и совершать покупки с сайтов, использующих HTTPS</li></ul><img src="./Модуль 11_files/http-https.png" alt=""></section><!-- SECTION --><section><h2 id="rest">Ознакомление с REST архитектурой</h2><p><strong>REST (Representational state transfer)</strong> - представляет собой стиль архитектуры, основанный на наборе принципов, которые описывают как сетевые ресурсы определяются и адресуются.</p><p><strong>REST API</strong> - работает как 'вебсайт', мы посылаем запрос с клиента на сервер и получаем ответ по http(s) протоколу.</p><h3>Архитектурные ограничения</h3><p>Шесть ограничений определяют REST систему. Они ограничивают способы, которыми сервер может обрабатывать и отвечать на запросы клиентов. Оперируя в рамках этих ограничений, сервис получает такие нефункциональные свойства как производительность, масштабируемость, простота, изменчивость, видимость, мобильность и надежность. Сервис нельзя считать RESt если он нарушает любые требуемые ограничения.</p><h4>Архитектура клиент-сервер</h4><p>Первое ограничение это клиент-сервер архитектура. Принцип модели клиент-сервер - это разделение задач. Разделение задач пользовательского интерфейса и проблем хранения данных повышает кроссплатформенность пользовательского интерфейса. Также улучшается масштабируемость за счет упрощения серверных компонентов. Разделение позволяет компонентам развиваться независимо друг от друга.</p><h4>Кэширование</h4><p>Ответ от сервера - данные, их можно кешировать. Поэтому ответы должны неявным или явным образом определять себя как кэшируемые или не запрещать клиентам повторно использовать устаревшие или несоответствующие данные в ответ на дальнейшие запросы. Хорошо управляемое кэширование еще больше повышает масштабируемость и производительность.</p><h4>Многослойная система</h4><p>Клиент, обычно, не может знать, подключен ли он непосредственно к конечному серверу или к посреднику на пути к конечному серверу. Промежуточные серверы могут улучшить масштабируемость системы за счет включения балансировки нагрузки и предоставления общих кэшей. Они также могут применять политики безопасности.</p><h4>Код по запросу</h4><p>Необязательное ограничение. Серверы могут временно расширять функционал клиента, передавая исполняемый код. Примерами этого могут быть скомпилированные компоненты, такие как клиентские JavaScript скрипты.</p><h4>Единый интерфейс</h4><p>Единое ограничение интерфейса является основополагающим для проектирования любой REST службы. Это упрощает и отделяет архитектуру, что в свою очередь позволяет каждой части развиваться независимо.</p><ul><li><a href="https://www.youtube.com/watch?v=YCcAE2SCQ6k" target="_blank">Видео о REST</a></li><li><a href="https://www.youtube.com/watch?time_continue=10&amp;v=llpr5924N7E" target="_blank">Видео о REST</a></li></ul></section><!-- SECTION --><section><h2 id="data">Форматы данных JSON/XML/CSV</h2><p>В современном вебе можно выделить 3 основные формата данных которыми обмениваются сервер и клиент.</p><ul><li><a href="https://en.wikipedia.org/wiki/Comma-separated_values" target="_blank"><strong>CSV</strong></a> - в виде псевдотаблиц, как наборы строк разделенных запятыми.</li><li><a href="https://en.wikipedia.org/wiki/XML" target="_blank"><strong>XML</strong></a> - в виде языка разметки данных XML. Имеет излишнее количество служебной информации при представлении данных.</li><li><a href="http://www.json.org/index.html" target="_blank"><strong>JSON</strong></a> - самый популярный формат на сегодняшний день. Объектоподобный синтаксис очень удобен для описания данных.</li></ul></section><!-- SECTION --><section><h2 id="fetch">Fetch API</h2><p><a href="https://goo.gl/w17gH3" target="_blank"><strong>Fetch API</strong></a> предоставляет интерфейс для получения ресурсов (файлов и любых других данных) от сервера, и является набором функций. Обеспечивает обобщенное определение объектов <code>Request</code> (запрос) и <code>Response</code> (ответ).</p><p><code>fetch(url, options)</code> - метод объекта window.</p><p>Принимает 2 аргумента:</p><ul><li><code>url</code> - обязательный, путь к данным которые вы хотите получить.</li><li><code>options</code> - необязатльнный, объект настроек запроса.</li></ul><p>Он возвращает <code>promise</code>, который содержит ответ <code>Response</code> на запрос, если все прошло удачно.</p><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0; line-height: 125%">fetch(<span style="color: #aa5500">"https://test-website.name/some/url"</span>)
  .then(<span style="color: #0000aa">function</span>(response) {
    <span style="color: #aaaaaa; font-style: italic">//response handling</span>
  })
  .then(<span style="color: #0000aa">function</span>(data) {
    <span style="color: #aaaaaa; font-style: italic">// data handling</span>
  })
  .<span style="color: #0000aa">catch</span>(<span style="color: #0000aa">function</span>(err) {
    <span style="color: #aaaaaa; font-style: italic">// error handling</span>
  });
</pre></div><br><h4>Response</h4><p><a href="https://goo.gl/8b7UVc" target="_blank"><strong>Response</strong></a> - в первый <code>then</code> метода <code>fetch</code> (напомним, fetch вернет promise, then это метод обещания) передается экземпляр класса <code>Response</code>. В нем содержится служебная информация о состоянии ответа сервера. Класс <code>Response</code> 'снабжает' екземпляры методами.</p><h4>Headers</h4><p><a href="https://goo.gl/W2KopN" target="_blank"><strong>Headers</strong></a> - позволяет выполнять различные действия в заголовках HTTP-запроса и ответа. Эти действия включают в себя извлечение, настройку, добавление и удаление заголовков (методы <code>append</code>, <code>has</code>, <code>get</code>, <code>set</code>, <code>delete</code>).</p><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">const</span> headers = <span style="color: #0000aa">new</span> Headers();

headers.append(<span style="color: #aa5500">"Content-Type"</span>, <span style="color: #aa5500">"text/plain"</span>);
headers.append(<span style="color: #aa5500">"X-Custom-Header"</span>, <span style="color: #aa5500">"custom value"</span>);
headers.has(<span style="color: #aa5500">"Content-Type"</span>); <span style="color: #aaaaaa; font-style: italic">// true</span>
headers.get(<span style="color: #aa5500">"Content-Type"</span>); <span style="color: #aaaaaa; font-style: italic">// "text/plain"</span>
headers.set(<span style="color: #aa5500">"Content-Type"</span>, <span style="color: #aa5500">"application/json"</span>);
headers.<span style="color: #0000aa">delete</span>(<span style="color: #aa5500">"X-Custom-Header"</span>);
</pre></div><br><p>Для составления заголовков запроса можно использовать объект настроек при вызове <code>new Headers</code>, с парами <code>ключ:значение</code>.</p><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">const</span> headers = <span style="color: #0000aa">new</span> Headers({
  <span style="color: #aa5500">'Content-Type'</span>: <span style="color: #aa5500">'application/json'</span>,
  <span style="color: #aa5500">'X-Custom-Header'</span>: <span style="color: #aa5500">'custom value'</span>
});
</pre></div><br><p>Простой fetch-запрос с использованием заголовков может выглядеть так.</p><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0; line-height: 125%">fetch(<span style="color: #aa5500">'my-cool-website.net/data'</span>, {
  method: <span style="color: #aa5500">'get'</span>,
  headers: <span style="color: #0000aa">new</span> Headers({
    <span style="color: #aa5500">'Content-Type'</span>: <span style="color: #aa5500">'application/json'</span>,
    <span style="color: #aa5500">'X-Custom-Header'</span>: <span style="color: #aa5500">'custom value'</span>
  })
}).then(<span style="color: #0000aa">function</span>() { <span style="color: #009999">/.../</span>});
</pre></div><br><h4>Request</h4><p><a href="https://goo.gl/UjcUg7" target="_blank"><strong>Request</strong></a> - экземпляр этого класса представляет собой ту часть <code>fetch</code>, в которой хранится служебная информация запроса. Используется в совокупности с технологией <a href="https://goo.gl/dzAVWd" target="_blank">Service Workers</a>.</p><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">const</span> request = <span style="color: #0000aa">new</span> Request(<span style="color: #aa5500">'my-cool-website.net/data'</span>, {
  method: <span style="color: #aa5500">'get'</span>,
  mode: <span style="color: #aa5500">'cors'</span>,
  headers: <span style="color: #0000aa">new</span> Headers({
    <span style="color: #aa5500">'Content-Type'</span>: <span style="color: #aa5500">'application/json'</span>,
    <span style="color: #aa5500">'X-Custom-Header'</span>: <span style="color: #aa5500">'custom value'</span>
  })
});

fetch(request).then(<span style="color: #0000aa">function</span>() { <span style="color: #009999">/.../</span>});
</pre></div><br><h3>Простой запрос</h3><p>Рассмотрим пример простого запроса.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_gGaaqg" src="./Модуль 11_files/gGaaqg.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="module-11-simple-fetch" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>Ошибка при работе с асинхронным кодом</h4><p>Разберем распространенную ошибку начинающих разработчиков, попытку использовать данные вне метода <code>then</code>, используем для этого предыдущий пример.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_veOrOa" src="./Модуль 11_files/veOrOa.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="module-11-async-call-mistake" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><!-- SECTION --><section><h2 id="api-basics">Основы работы с API</h2><p><strong>API (интерфейс прикладного программирования)</strong> - набор четко определенных способов связи между различными программными компонентами. Впринципе, это описание открытого доступа к закрытой программе. API описывает что можно попросить программу сделать и что получить в результате. Наиболее часто API размещают на серверах подключенных к web.</p><p><strong>Сервер</strong> - это программа, расположенная на компъютре настроеном на обработку запросов, способная получить запрос на определенный адрес и имеющая набор готовых действий на определенные запросы.</p><p>Адрес сервера это как правило ip адрес и номер порта. ip адрес - это возможность найти определенный компьютер, а номер порта - возможность найти определенную программу на этом компьютере.</p><!-- subsection --><h3>Работа с Web API</h3><p>Каждый API уникален, невозможно заучить 'код' для работы с одним API и использовать его для общения с другим. Можно понять принцип и методы работы, после чего, все что нужно сделать, это ознакомиться с документацией API который необходимо использовать.</p><p>Для примера был выбран API ПриватБанка <a href="https://api.privatbank.ua/" target="_blank"><code>api.privatbank.ua</code></a></p><h4>Получаем курс валют</h4><p><a href="https://api.privatbank.ua/#p24/exchange" target="_blank">Документация о запросах на курс валют.</a></p><p><code>https://api.privatbank.ua/p24api/pubinfo?exchange&amp;json&amp;coursid=11</code> - url для обращения к API ПриватБанка для получения ответа о текущем курсе обмена.</p><p>Состоит из:</p><ul><li><strong>https://api.privatbank.ua</strong> - endpoint, server, base URL, host. Точка входа на сервер.</li><li><strong>p24api/pubinfo</strong> - ресурс к которому мы обращаемся</li><li><strong>?</strong> - говорит о том что после идут параметры запроса</li><li><strong>&amp;</strong> - используется для указания смыслового 'и', он связывает множественные параметры запроса</li></ul><p>Параметры ответа из документации:</p><table><tbody><tr><th>Название</th><th>Описание</th></tr><tr><td><code>ccy</code></td><td>Код валюты (справочник кодов валют: https://ru.wikipedia.org/wiki/Коды_валют)</td></tr><tr><td><code>base_ccy</code></td><td>Код национальной валюты</td></tr><tr><td><code>buy</code></td><td>Курс покупки</td></tr><tr><td><code>sale</code></td><td>Курс продажи</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_JrYGVE" src="./Модуль 11_files/JrYGVE.html" scrolling="no" frameborder="0" height="500" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="module-11-privat-api" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section></article><!-- ============================== #page-navigator =============================================  --> <a href="http://fecore.net.ua/advanced/theory/module-11.html#page-nav" class="to-page-nav"></a><!-- ============================== #end page-navigator =============================================  --></div></body></html>